<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" href="./richfavicon.png" sizes="32x32">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Rive QnA • Google Sheet Driven</title>
  <style>
    body { font-family: sans-serif; margin: 0; padding: 0; background: #FFF; }
    #rive-canvas { position: absolute; inset: 0; width: 100%; height: 100%; display: block; background: #FFF; }
  </style>
</head>

<body>
  <canvas id="rive-canvas"></canvas>

  <script src="https://unpkg.com/@rive-app/webgl2@2" crossorigin="anonymous"></script>
  <script>
    // === 1) Layout & canvas sizing ===
    const layout = new rive.Layout({
      fit: rive.Fit.layout || rive.Fit.Layout,
      layoutScaleFactor: 1,
    });

    const canvas = document.getElementById('rive-canvas');

    function resizeCanvas() {
      try { riveInstance.resizeDrawingSurfaceToCanvas(); } catch {}
    }
    window.addEventListener('resize', resizeCanvas);
    window.matchMedia(`(resolution: ${devicePixelRatio}dppx)`).addEventListener('change', resizeCanvas);

    // === 2) CSV source (Sheet2) ===
    const SHEET_CSV_URL =
      'https://docs.google.com/spreadsheets/d/e/2PACX-1vS64L8Iiv3nFx37zMVVVm6XBUv216nmMXpBp4s_bpU-wD9BmrdfyGVGqB94Lkcdrn24jwLFYeArTs6p/pub?gid=443444412&single=true&output=csv';

    // CSV splitter that respects quotes
    function splitCSVLine(line) {
      const out = [];
      let cur = '';
      let inQuotes = false;
      for (let i = 0; i < line.length; i++) {
        const ch = line[i];
        if (ch === '"') {
          if (inQuotes && line[i + 1] === '"') { cur += '"'; i++; }
          else inQuotes = !inQuotes;
        } else if (ch === ',' && !inQuotes) {
          out.push(cur.trim());
          cur = '';
        } else {
          cur += ch;
        }
      }
      out.push(cur.trim());
      return out.map(s => s.replace(/^"|"$/g, '').trim());
    }

    // Fetch rows and map -> { q, correct, distractors: [..] }
    async function fetchQA() {
      const res = await fetch(SHEET_CSV_URL, { cache: 'no-store' });
      const text = await res.text();
      return text
        .split(/\r?\n/)
        .map(l => l.trim())
        .filter(l => l.length)
        .map(line => {
          const cols = splitCSVLine(line);
          return {
            q: (cols[0] ?? '').trim(),
            correct: (cols[1] ?? '').trim(),            // Column B is ALWAYS correct
            distractors: [cols[2] ?? '', cols[3] ?? '', cols[4] ?? '']
              .map(s => String(s).trim())
              .filter(s => s.length)
          };
        })
        // Keep rows that at least have a question + a correct answer
        .filter(r => r.q && r.correct);
    }

    // Fisher–Yates shuffle
    function shuffle(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    // === 3) Rive setup ===
    let riveInstance, vmi;
    let btnTrigger, questionProp, ans1, ans2, ans3, ans4, answerSelect, scoreProp;
    let qaRows = [];
    let idx = 0;
    let currentCorrectSlot = 0; // 1..4 position where the correct answer ended up

    // Watch a VM prop (prefers prop.on, else polls)
    function observe(prop, cb) {
      if (!prop) return () => {};
      if (typeof prop.on === 'function') {
        prop.on(cb);
        return () => { try { prop.on(null); } catch {} };
      }
      let last = prop.value;
      const id = setInterval(() => {
        const now = prop.value;
        if (now !== last) {
          last = now;
          try { cb(now); } catch {}
        }
      }, 100);
      return () => clearInterval(id);
    }

    function applyRow(i) {
      if (!qaRows.length) return;
      const r = qaRows[((i % qaRows.length) + qaRows.length) % qaRows.length];

      // Build options: ensure we have up to 4 options including the correct one.
      const options = [r.correct, ...(r.distractors || [])].slice(0, 4);
      // If fewer than 4, pad with blanks to avoid undefined
      while (options.length < 4) options.push('');

      // Shuffle while tracking where the correct one lands
      const shuffled = shuffle(options);
      currentCorrectSlot = (shuffled.findIndex(x => x === r.correct) + 1) || 0; // 1..4

      // Push into VM
      if (questionProp) questionProp.value = String(r.q);
      if (ans1) ans1.value = String(shuffled[0] ?? '');
      if (ans2) ans2.value = String(shuffled[1] ?? '');
      if (ans3) ans3.value = String(shuffled[2] ?? '');
      if (ans4) ans4.value = String(shuffled[3] ?? '');

      // Reset selection each question
      if (answerSelect && typeof answerSelect.value !== 'undefined') {
        answerSelect.value = 0;
      }

      idx = i;
    }

    function next() { applyRow(idx + 1); }

    riveInstance = new rive.Rive({
      src: 'duolingointeraction.riv',
      canvas: canvas,
      autoplay: true,
      autoBind: true,
      stateMachines: 'State Machine 1',
      artboard: 'Dashboard',
      layout: layout,
      onLoad: async function () {
        resizeCanvas();

        vmi = riveInstance.viewModelInstance;
        if (!vmi) { console.warn('No ViewModel instance found.'); return; }

        // Bind VM properties (ensure they’re visible in Rive)
        questionProp  = vmi.string?.('Question');
        ans1          = vmi.string?.('Answer1');
        ans2          = vmi.string?.('Answer2');
        ans3          = vmi.string?.('Answer3');
        ans4          = vmi.string?.('Answer4');
        answerSelect  = vmi.number?.('AnswerSelect');  // expects 0 (none) or 1..4
        scoreProp     = vmi.number?.('Score');         // optional, if you want to track score
        btnTrigger    = vmi.trigger?.('BtnPressTrig');

        // Load QA, apply first row
        try {
          qaRows = await fetchQA();
          if (qaRows.length) applyRow(0);
          else console.warn('No rows found in sheet.');
        } catch (e) {
          console.warn('Failed to fetch questions:', e);
        }

        // Advance on trigger fire
        if (btnTrigger && typeof btnTrigger.on === 'function') {
          btnTrigger.on(() => next());
        }

        // Listen for answer selection changes and report correctness
        observe(answerSelect, (val) => {
          const choice = Number(val);
          if (!Number.isFinite(choice) || choice === 0) return; // 0 = none selected
          const isCorrect = (choice === currentCorrectSlot);
          console.log(isCorrect ? '✅ Correct!' : `❌ Wrong (picked ${choice}, correct is ${currentCorrectSlot})`);

          // Optional: update score
          // if (isCorrect && scoreProp && typeof scoreProp.value !== 'undefined') {
          //   scoreProp.value = Number(scoreProp.value || 0) + 1;
          // }
        });

        // Debug helpers
        window._vm = {
          next, applyRow,
          get rows(){ return qaRows; },
          get index(){ return idx; },
          get correctSlot(){ return currentCorrectSlot; }
        };
      }
    });
  </script>
</body>
</html>
