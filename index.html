<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" href="./richfavicon.png" sizes="32x32">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Rive QnA • Google Sheet Driven</title>
  <style>
    body { font-family: sans-serif; margin: 0; padding: 0; background: #FFF; }
    #rive-canvas { position: absolute; inset: 0; width: 100%; height: 100%; display: block; background: #FFF; }
  </style>
</head>

<body>
  <canvas id="rive-canvas"></canvas>

  <script src="https://unpkg.com/@rive-app/webgl2@2" crossorigin="anonymous"></script>
  <script>
    // === Layout & canvas sizing ===
    const layout = new rive.Layout({
      fit: rive.Fit.layout || rive.Fit.Layout,
      layoutScaleFactor: 1,
    });

    const canvas = document.getElementById('rive-canvas');
    function resizeCanvas() { try { riveInstance.resizeDrawingSurfaceToCanvas(); } catch {} }
    window.addEventListener('resize', resizeCanvas);
    window.matchMedia(`(resolution: ${devicePixelRatio}dppx)`).addEventListener('change', resizeCanvas);

    // === CSV source ===
    const SHEET_CSV_URL =
      'https://docs.google.com/spreadsheets/d/e/2PACX-1vS64L8Iiv3nFx37zMVVVm6XBUv216nmMXpBp4s_bpU-wD9BmrdfyGVGqB94Lkcdrn24jwLFYeArTs6p/pub?gid=443444412&single=true&output=csv';

    // CSV line split that respects quotes
    function splitCSVLine(line) {
      const out = []; let cur = ''; let inQuotes = false;
      for (let i = 0; i < line.length; i++) {
        const ch = line[i];
        if (ch === '"') {
          if (inQuotes && line[i + 1] === '"') { cur += '"'; i++; }
          else inQuotes = !inQuotes;
        } else if (ch === ',' && !inQuotes) { out.push(cur.trim()); cur = ''; }
        else { cur += ch; }
      }
      out.push(cur.trim());
      return out.map(s => s.replace(/^"|"$/g, '').trim());
    }

    // Fetch questions & answers from sheet
    async function fetchQA() {
      const res = await fetch(SHEET_CSV_URL, { cache: 'no-store' });
      const text = await res.text();
      return text
        .split(/\r?\n/)
        .map(l => l.trim())
        .filter(l => l.length)
        .map(line => {
          const cols = splitCSVLine(line);
          return {
            q: (cols[0] ?? '').trim(),
            correct: (cols[1] ?? '').trim(),                  // B = correct
            distractors: [cols[2] ?? '', cols[3] ?? '', cols[4] ?? '']
              .map(s => s.trim())
              .filter(s => s.length)
          };
        })
        .filter(r => r.q && r.correct);
    }

    // Shuffle util
    function shuffle(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    // === Rive setup ===
    let riveInstance, vmi;
    let btnTrigger, questionProp, ans1, ans2, ans3, ans4, answerSelect, isCorrectProp, progressProp;

    let qaRows = [];
    let idx = 0;
    let currentCorrectSlot = 0; // 1..4 where correct landed
    let advancing = false;       // latch to prevent double-advance on rapid clicks

    function observe(prop, cb) {
      if (!prop) return () => {};
      if (typeof prop.on === 'function') { prop.on(cb); return () => { try { prop.on(null); } catch {} }; }
      let last = prop.value;
      const id = setInterval(() => {
        const now = prop.value;
        if (now !== last) { last = now; try { cb(now); } catch {} }
      }, 100);
      return () => clearInterval(id);
    }

    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

    function applyRow(i) {
      if (!qaRows.length) return;
      const r = qaRows[((i % qaRows.length) + qaRows.length) % qaRows.length];

      const options = [r.correct, ...(r.distractors || [])].slice(0, 4);
      while (options.length < 4) options.push('');

      const shuffled = shuffle(options);
      currentCorrectSlot = (shuffled.findIndex(x => x === r.correct) + 1) || 0;

      if (questionProp) questionProp.value = r.q;
      if (ans1) ans1.value = shuffled[0] ?? '';
      if (ans2) ans2.value = shuffled[1] ?? '';
      if (ans3) ans3.value = shuffled[2] ?? '';
      if (ans4) ans4.value = shuffled[3] ?? '';

      // Rive timelines will also reset this, but we hard reset for safety
      if (answerSelect) answerSelect.value = 0;

      idx = i;
      advancing = false;
    }

    function next() { applyRow(idx + 1); }

    riveInstance = new rive.Rive({
    src: 'duolingointeraction.riv',
    canvas: canvas,
    autoplay: true,
    autoBind: true,
    stateMachines: 'State Machine 1',
    artboard: 'Dashboard',
    layout: layout,
    onLoad: async function () {
      resizeCanvas();

      vmi = riveInstance.viewModelInstance;
      if (!vmi) { console.warn('No ViewModel instance found.'); return; }

      // Bind props
      questionProp  = vmi.string?.('Question');
      ans1          = vmi.string?.('Answer1');
      ans2          = vmi.string?.('Answer2');
      ans3          = vmi.string?.('Answer3');
      ans4          = vmi.string?.('Answer4');
      answerSelect  = vmi.number?.('AnswerSelect'); 
      isCorrectProp = (vmi.bool || vmi.boolean)?.call(vmi, 'isCorrect'); 
      progressProp  = vmi.number?.('Progress');     
      btnTrigger    = vmi.trigger?.('BtnPressTrig');

      try {
        qaRows = await fetchQA();
        qaRows = shuffle(qaRows);   
        if (qaRows.length) applyRow(0);
      } catch (e) {
        console.warn('Failed to fetch questions:', e);
      }

      // Watch answer selection — set isCorrect here
      observe(answerSelect, (val) => {
        const choice = Number(val);
        if (!Number.isFinite(choice) || choice === 0) return;

        const correct = (choice === currentCorrectSlot);

        if (isCorrectProp && 'value' in isCorrectProp) {
          isCorrectProp.value = !!correct;   // update boolean immediately
        }

        console.log(`User selected option ${choice} → ${correct ? '✅ Correct' : '❌ Wrong'}`);
      });

      // Confirm button (BtnPressTrig)
      if (btnTrigger && typeof btnTrigger.on === 'function') {
        btnTrigger.on(() => {
          if (advancing) return;

          const choice = Number(answerSelect?.value ?? 0);
          if (!Number.isFinite(choice) || choice === 0) return;

          const correct = (choice === currentCorrectSlot);

          if (correct) {
            if (progressProp && typeof progressProp.value !== 'undefined') {
              const cur = Number(progressProp.value || 0);
              progressProp.value = clamp(cur + 10, 0, 100);
            }
            advancing = true;
            setTimeout(() => { next(); }, 550);
          }
          // If wrong: do nothing — Rive will reset AnswerSelect to 0 via timeline
        });
      }
    }
  });
</script>
</body>
</html>
