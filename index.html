<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" href="./richfavicon.png" sizes="32x32">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Rive QnA ‚Ä¢ Google Sheet Driven</title>
  <style>
    body { font-family: sans-serif; margin: 0; padding: 0; background: #FFF; }
    #rive-canvas { position: absolute; inset: 0; width: 100%; height: 100%; display: block; background: #FFF; }
  </style>
</head>

<body>
  <canvas id="rive-canvas"></canvas>

  <script src="https://unpkg.com/@rive-app/webgl2@2" crossorigin="anonymous"></script>
  <script>
    // === Layout & canvas sizing ===
    const layout = new rive.Layout({
      fit: rive.Fit.layout || rive.Fit.Layout,
      layoutScaleFactor: 1,
    });

    const canvas = document.getElementById('rive-canvas');
    function resizeCanvas() {
      try { riveInstance.resizeDrawingSurfaceToCanvas(); } catch {}
    }
    window.addEventListener('resize', resizeCanvas);
    window.matchMedia(`(resolution: ${devicePixelRatio}dppx)`).addEventListener('change', resizeCanvas);

    // === CSV source ===
    const SHEET_CSV_URL =
      'https://docs.google.com/spreadsheets/d/e/2PACX-1vS64L8Iiv3nFx37zMVVVm6XBUv216nmMXpBp4s_bpU-wD9BmrdfyGVGqB94Lkcdrn24jwLFYeArTs6p/pub?gid=443444412&single=true&output=csv';

    // Split CSV line respecting quotes
    function splitCSVLine(line) {
      const out = []; let cur = ''; let inQuotes = false;
      for (let i = 0; i < line.length; i++) {
        const ch = line[i];
        if (ch === '"') {
          if (inQuotes && line[i + 1] === '"') { cur += '"'; i++; }
          else inQuotes = !inQuotes;
        } else if (ch === ',' && !inQuotes) {
          out.push(cur.trim()); cur = '';
        } else cur += ch;
      }
      out.push(cur.trim());
      return out.map(s => s.replace(/^"|"$/g, '').trim());
    }

    // Fetch questions & answers from sheet
    async function fetchQA() {
      const res = await fetch(SHEET_CSV_URL, { cache: 'no-store' });
      const text = await res.text();
      return text
        .split(/\r?\n/)
        .map(l => l.trim())
        .filter(l => l.length)
        .map(line => {
          const cols = splitCSVLine(line);
          return {
            q: (cols[0] ?? '').trim(),
            correct: (cols[1] ?? '').trim(),
            distractors: [cols[2] ?? '', cols[3] ?? '', cols[4] ?? '']
              .map(s => s.trim())
              .filter(s => s.length)
          };
        })
        .filter(r => r.q && r.correct);
    }

    // Shuffle util
    function shuffle(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    // === Rive setup ===
    let riveInstance, vmi;
    let btnTrigger, questionProp, ans1, ans2, ans3, ans4, answerSelect;
    let qaRows = [];
    let idx = 0;
    let currentCorrectSlot = 0; // 1..4 where correct landed

    function observe(prop, cb) {
      if (!prop) return () => {};
      if (typeof prop.on === 'function') {
        prop.on(cb);
        return () => { try { prop.on(null); } catch {} };
      }
      let last = prop.value;
      const id = setInterval(() => {
        const now = prop.value;
        if (now !== last) { last = now; try { cb(now); } catch {} }
      }, 100);
      return () => clearInterval(id);
    }

    function applyRow(i) {
      if (!qaRows.length) return;
      const r = qaRows[((i % qaRows.length) + qaRows.length) % qaRows.length];

      const options = [r.correct, ...(r.distractors || [])].slice(0, 4);
      while (options.length < 4) options.push('');

      const shuffled = shuffle(options);
      currentCorrectSlot = (shuffled.findIndex(x => x === r.correct) + 1) || 0;

      if (questionProp) questionProp.value = r.q;
      if (ans1) ans1.value = shuffled[0] ?? '';
      if (ans2) ans2.value = shuffled[1] ?? '';
      if (ans3) ans3.value = shuffled[2] ?? '';
      if (ans4) ans4.value = shuffled[3] ?? '';

      if (answerSelect) answerSelect.value = 0;
      idx = i;
    }

    function next() { applyRow(idx + 1); }

    riveInstance = new rive.Rive({
      src: 'duolingointeraction.riv',
      canvas: canvas,
      autoplay: true,
      autoBind: true,
      stateMachines: 'State Machine 1',
      artboard: 'Dashboard',
      layout: layout,
      onLoad: async function () {
        resizeCanvas();

        vmi = riveInstance.viewModelInstance;
        if (!vmi) { console.warn('No ViewModel instance found.'); return; }

        // Bind props
        questionProp = vmi.string?.('Question');
        ans1 = vmi.string?.('Answer1');
        ans2 = vmi.string?.('Answer2');
        ans3 = vmi.string?.('Answer3');
        ans4 = vmi.string?.('Answer4');
        answerSelect = vmi.number?.('AnswerSelect');
        btnTrigger = vmi.trigger?.('BtnPressTrig');

        try {
          qaRows = await fetchQA();
          qaRows = shuffle(qaRows);   // üëà randomise question order
          if (qaRows.length) applyRow(0);
        } catch (e) {
          console.warn('Failed to fetch questions:', e);
        }

        if (btnTrigger && typeof btnTrigger.on === 'function') {
          btnTrigger.on(() => next());
        }

        observe(answerSelect, (val) => {
          const choice = Number(val);
          if (!Number.isFinite(choice) || choice === 0) return;
          const isCorrect = (choice === currentCorrectSlot);
          console.log(isCorrect ? '‚úÖ Correct!' : `‚ùå Wrong (picked ${choice}, correct was ${currentCorrectSlot})`);
        });

        window._vm = { next, applyRow, get rows(){return qaRows;}, get index(){return idx;}, get correctSlot(){return currentCorrectSlot;} };
      }
    });
  </script>
</body>
</html>
